<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TC Track Auto Writer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a clean, high-contrast UI */
        body {
            font-family: 'Inter', sans-serif;
            color: #e0e0e0;
            background-color: #121212;
            user-select: none; /* REFINEMENT: Prevent text selection while dragging */
        }
        .control-panel {
            background-color: #1e1e1e;
        }
        .map-container {
            position: relative;
            overflow: auto;
            cursor: crosshair;
            border-left: 2px solid #333;
        }
        /* REFINEMENT: Add grabbing cursor style for when user is dragging the map */
        .map-container.dragging {
            cursor: grabbing;
        }
        #mapCanvas, #mapImage {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: top left;
        }
        #mapCanvas {
            pointer-events: none; /* Allows clicks to pass through to the map image */
        }
        #mapImage {
            display: block;
            max-width: none;
        }
        input, select, textarea, button {
            background-color: #2a2a2a;
            border: 1px solid #444;
            color: #e0e0e0;
            border-radius: 0.375rem;
            padding: 0.5rem 0.75rem;
            transition: all 0.2s ease-in-out;
        }
        input[type="datetime-local"]::-webkit-calendar-picker-indicator {
            filter: invert(1);
        }
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #4a90e2;
            box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.5);
        }
        input[type="color"] {
            padding: 0;
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            background-color: transparent;
            border: 1px solid #444;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 0.375rem; }
        button { cursor: pointer; background-color: #3a3a3a; }
        button:hover { background-color: #4a4a4a; }
        .btn-primary { background-color: #4a90e2; color: #fff; }
        .btn-primary:hover { background-color: #357abd; }
        .btn-danger { background-color: #e24a4a; color: #fff; }
        .btn-danger:hover { background-color: #bd3535; }
        label { font-weight: 500; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1e1e1e; }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #666; }
    </style>
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
</head>
<body class="h-screen w-screen overflow-hidden flex flex-col">

    <header class="bg-gray-900 text-white p-3 shadow-md z-10">
        <h1 class="text-xl font-bold">TC Track Auto Writer</h1>
    </header>

    <div class="flex flex-1 overflow-hidden">

        <aside class="control-panel w-full md:w-96 p-4 overflow-y-auto flex flex-col space-y-4">
            <div class="space-y-2 p-3 bg-gray-800 rounded-lg">
                <h2 class="text-lg font-semibold border-b border-gray-600 pb-1 mb-2">System ID & Type</h2>
                <div class="grid grid-cols-2 gap-2">
                    <div>
                        <label for="basin" class="block text-sm">Basin</label>
                        <input type="text" id="basin" value="WP" class="w-full">
                    </div>
                    <div>
                        <label for="systemId" class="block text-sm">Number</label>
                        <input type="text" id="systemId" value="01" class="w-full">
                    </div>
                </div>
                 <div>
                    <label for="intensity" class="block text-sm">Intensity (kt)</label>
                    <input type="number" id="intensity" value="25" class="w-full">
                </div>
                <div>
                    <label for="systemType" class="block text-sm">System Type</label>
                    <select id="systemType" class="w-full">
                        <option value="TD" selected>Tropical Depression (TD)</option>
                        <option value="SS">Subtropical Storm (SS)</option>
                        <option value="TS">Tropical Storm (TS)</option>
                        <option value="TY">Typhoon (TY)</option>
                        <option value="ST">Super Typhoon (ST)</option>
                        <option value="EX">Extratropical (EX)</option>
                        <option value="DB">Disturbance (DB)</option>
                    </select>
                </div>
            </div>
            <div class="space-y-2 p-3 bg-gray-800 rounded-lg">
                <h2 class="text-lg font-semibold border-b border-gray-600 pb-1 mb-2">Settings</h2>
                <div>
                    <label for="initialTime" class="block text-sm">Initial Time (UTC)</label>
                    <input type="datetime-local" id="initialTime" class="w-full">
                </div>
                 <div>
                    <label for="pointSize" class="block text-sm">Point Size</label>
                    <input type="number" id="pointSize" value="6" min="1" max="20" class="w-full">
                </div>
            </div>
            <div class="space-y-2 p-3 bg-gray-800 rounded-lg">
                <h2 class="text-lg font-semibold border-b border-gray-600 pb-1 mb-2">Intensity Color Rules (Min KT)</h2>
                <div id="colorRules" class="grid grid-cols-2 gap-4 text-sm"></div>
            </div>
            <div class="flex-grow flex flex-col p-3 bg-gray-800 rounded-lg">
                 <h2 class="text-lg font-semibold border-b border-gray-600 pb-1 mb-2">Formatted Output</h2>
                <textarea id="output" readonly class="w-full flex-grow text-xs font-mono resize-none"></textarea>
            </div>
            <div class="grid grid-cols-2 gap-2 pt-2">
                <button id="clearLastBtn" class="btn-danger w-full">Clear Last Point</button>
                <button id="exportBtn" class="btn-primary w-full">Export Data</button>
            </div>
        </aside>

        <main id="mapContainer" class="map-container flex-1">
            <img id="mapImage" src="./blue_marble.png" alt="Global Map" width="15306" height="7653" onerror="this.outerHTML='<div style=\'width: 15306px; height: 7653px; background: #333; color: white; display: flex; align-items: center; justify-content: center; font-size: 2rem; padding: 2rem; text-align: center;\'>Error: Map image (blue_marble.png) not found.<br>Please ensure the image file is in the same folder as this HTML file.</div>'">
            <canvas id="mapCanvas" width="15306" height="7653"></canvas>
        </main>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- CONFIGURATION CONSTANTS ---
            const MAP_WIDTH = 15306;
            const MAP_HEIGHT = 7653;
            const EQ_Y_PX = 3826.5;
            const PM_X_PX = 7653;
            const PX_PER_DEG = 42.5;

            // --- DOM ELEMENT REFERENCES ---
            const mapContainer = document.getElementById('mapContainer');
            const mapImage = document.getElementById('mapImage');
            const canvas = document.getElementById('mapCanvas');
            const ctx = canvas.getContext('2d');
            const basinInput = document.getElementById('basin');
            const systemIdInput = document.getElementById('systemId');
            const intensityInput = document.getElementById('intensity');
            const systemTypeInput = document.getElementById('systemType');
            const initialTimeInput = document.getElementById('initialTime');
            const pointSizeInput = document.getElementById('pointSize');
            const outputTextarea = document.getElementById('output');
            const clearLastBtn = document.getElementById('clearLastBtn');
            const exportBtn = document.getElementById('exportBtn');
            const colorRulesContainer = document.getElementById('colorRules');

            // --- APPLICATION STATE ---
            let trackPoints = [];
            let baseTime = null;
            let colorRules = [
                { threshold: 139, color: '#FF00FF' }, { threshold: 114, color: '#FF4500' },
                { threshold: 99,  color: '#FF8C00' }, { threshold: 84,  color: '#FFD700' },
                { threshold: 64,  color: '#FF0000' }, { threshold: 34,  color: '#00FF00' },
                { threshold: 24,  color: '#00BFFF' }, { threshold: 0,   color: '#FFFFFF' }
            ];
            
            // --- REFINEMENT: State for map scaling, panning, and interaction ---
            let scale = 1.0;
            const MIN_SCALE = 0.1;
            const MAX_SCALE = 5.0;
            let isDragging = false;
            let hasDragged = false;
            let lastDragX = 0;
            let lastDragY = 0;


            // --- INITIALIZATION ---
            function initialize() {
                initialTimeInput.value = formatToDateTimeLocal(new Date());
                renderColorRules();
                attachEventListeners();
                // Center the map on the Western Pacific Ocean
                mapContainer.scrollTop = 2000;
                mapContainer.scrollLeft = 10000;
            }

            // --- DYNAMIC UI RENDERING ---
            function renderColorRules() {
                colorRulesContainer.innerHTML = '';
                colorRules.slice(0, -1).forEach((rule) => {
                    const div = document.createElement('div');
                    div.className = 'flex items-center space-x-2';
                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.value = rule.color;
                    colorInput.dataset.oldColor = rule.color;
                    colorInput.addEventListener('input', (e) => {
                        const newColor = e.target.value;
                        const oldColor = e.target.dataset.oldColor;
                        const ruleToUpdate = colorRules.find(r => r.color === oldColor);
                        if (ruleToUpdate) ruleToUpdate.color = newColor;
                        e.target.dataset.oldColor = newColor;
                        e.target.nextElementSibling.dataset.color = newColor;
                        drawTrack();
                    });
                    const thresholdInput = document.createElement('input');
                    thresholdInput.type = 'number';
                    thresholdInput.value = rule.threshold;
                    thresholdInput.className = 'w-full text-sm p-1';
                    thresholdInput.dataset.color = rule.color;
                    thresholdInput.addEventListener('change', (e) => {
                        const newThreshold = parseInt(e.target.value, 10);
                        const ruleColor = e.target.dataset.color;
                        if (!isNaN(newThreshold)) {
                            const ruleToUpdate = colorRules.find(r => r.color === ruleColor);
                            if(ruleToUpdate) ruleToUpdate.threshold = newThreshold;
                            colorRules.sort((a, b) => b.threshold - a.threshold);
                            renderColorRules();
                            drawTrack();
                        }
                    });
                    div.appendChild(colorInput);
                    div.appendChild(thresholdInput);
                    colorRulesContainer.appendChild(div);
                });
            }

            // --- EVENT HANDLING ---
            function attachEventListeners() {
                // REFINEMENT: Reworked event listeners for robust drag, zoom, and click actions.
                mapContainer.addEventListener('wheel', handleZoom);
                mapContainer.addEventListener('mousedown', handleMouseDown);
                mapContainer.addEventListener('mousemove', handleMouseMove);
                mapContainer.addEventListener('mouseup', handleMouseUp);
                mapContainer.addEventListener('mouseleave', handleMouseLeave);
                
                clearLastBtn.addEventListener('click', clearLastPoint);
                exportBtn.addEventListener('click', exportData);
                intensityInput.addEventListener('input', drawTrack);
                systemTypeInput.addEventListener('change', drawTrack);
                pointSizeInput.addEventListener('input', drawTrack);
            }

            // REFINEMENT: New handlers for mouse drag-to-pan functionality
            function handleMouseDown(e) {
                e.preventDefault();
                isDragging = true;
                hasDragged = false;
                mapContainer.classList.add('dragging');
                lastDragX = e.pageX;
                lastDragY = e.pageY;
            }

            function handleMouseMove(e) {
                if (!isDragging) return;
                e.preventDefault();
                hasDragged = true; // Mark that a drag has occurred
                const deltaX = e.pageX - lastDragX;
                const deltaY = e.pageY - lastDragY;
                mapContainer.scrollLeft -= deltaX;
                mapContainer.scrollTop -= deltaY;
                lastDragX = e.pageX;
                lastDragY = e.pageY;
            }
            
            function handleMouseUp(e) {
                isDragging = false;
                mapContainer.classList.remove('dragging');
                // If the mouse was not dragged, it was a click. Place a point.
                if (!hasDragged) {
                    const rect = mapContainer.getBoundingClientRect();
                    // Calculate the click position on the unscaled map
                    const x = (mapContainer.scrollLeft + e.clientX - rect.left) / scale;
                    const y = (mapContainer.scrollTop + e.clientY - rect.top) / scale;
                    addPointAt(x, y);
                }
            }

            function handleMouseLeave() {
                // Cancel dragging if the mouse leaves the container
                isDragging = false;
                mapContainer.classList.remove('dragging');
            }
            
            // REFINEMENT: Renamed from handleMapClick to be more descriptive.
            // Now accepts coordinates directly instead of an event.
            function addPointAt(x, y) {
                if (trackPoints.length === 0) {
                    const initialDate = initialTimeInput.value ? new Date(initialTimeInput.value) : new Date();
                    baseTime = roundToSynopticTime(initialDate);
                }
                const pointTime = new Date(baseTime.getTime());
                pointTime.setUTCHours(pointTime.getUTCHours() + trackPoints.length * 6);
                const geo = pixelToGeo(x, y);
                const intensity = parseInt(intensityInput.value, 10) || 0;
                const point = {
                    px: x, py: y,
                    lat: geo.lat, lon: geo.lon,
                    intensity: intensity,
                    systemType: systemTypeInput.value,
                    basin: basinInput.value.toUpperCase(),
                    systemId: systemIdInput.value.padStart(2, '0'),
                    timestamp: formatToUTCString(pointTime)
                };
                trackPoints.push(point);
                drawTrack();
                updateOutput();
            }
            
            function handleZoom(e) {
                e.preventDefault();
                const rect = mapContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const pointX = (mapContainer.scrollLeft + mouseX) / scale;
                const pointY = (mapContainer.scrollTop + mouseY) / scale;
                
                // REFINEMENT: Reduced sensitivity of zoom from 1.1/0.9 to 1.05/0.95
                const delta = e.deltaY < 0 ? 1.05 : 0.95;
                const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * delta));
                
                mapImage.style.transform = `scale(${newScale})`;
                canvas.style.transform = `scale(${newScale})`;
                mapContainer.scrollLeft = (pointX * newScale) - mouseX;
                mapContainer.scrollTop = (pointY * newScale) - mouseY;
                scale = newScale;
            }

            // --- CORE LOGIC & HELPERS ---
            function pixelToGeo(x, y) {
                const lon = (x - PM_X_PX) / PX_PER_DEG;
                const lat = (EQ_Y_PX - y) / PX_PER_DEG;
                return { lat: lat.toFixed(1), lon: lon.toFixed(1) };
            }

            function getColorForIntensity(intensity) {
                for (const rule of colorRules) {
                    if (intensity >= rule.threshold) return rule.color;
                }
                return colorRules[colorRules.length - 1].color;
            }

            function drawTrack() {
                const pointRadius = parseInt(pointSizeInput.value, 10) || 6;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (trackPoints.length === 0) return;
                ctx.beginPath();
                ctx.moveTo(trackPoints[0].px, trackPoints[0].py);
                for (let i = 1; i < trackPoints.length; i++) {
                    ctx.lineTo(trackPoints[i].px, trackPoints[i].py);
                }
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 2;
                ctx.stroke();
                trackPoints.forEach(point => {
                    ctx.fillStyle = getColorForIntensity(point.intensity);
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    switch (point.systemType) {
                        case 'TS': case 'SS':
                            ctx.rect(point.px - pointRadius, point.py - pointRadius, pointRadius * 2, pointRadius * 2);
                            break;
                        case 'DB': case 'EX':
                            const r = pointRadius + 2;
                            ctx.moveTo(point.px, point.py - r);
                            ctx.lineTo(point.px - r * Math.sqrt(3) / 2, point.py + r / 2);
                            ctx.lineTo(point.px + r * Math.sqrt(3) / 2, point.py + r / 2);
                            ctx.closePath();
                            break;
                        default:
                            ctx.arc(point.px, point.py, pointRadius, 0, 2 * Math.PI);
                            break;
                    }
                    ctx.fill();
                    ctx.stroke();
                });
            }

            function updateOutput() {
                const outputLines = trackPoints.map(p => {
                    const latStr = `${Math.abs(p.lat).toFixed(1)}${p.lat >= 0 ? 'N' : 'S'}`;
                    const lonStr = `${Math.abs(p.lon).toFixed(1)}${p.lon >= 0 ? 'E' : 'W'}`;
                    return `${p.basin}, ${p.systemId}, ${p.timestamp},    , BEST,   0, ${latStr}, ${lonStr},  ${p.intensity},    , ${p.systemType}`;
                });
                outputTextarea.value = outputLines.join('\n');
                outputTextarea.scrollTop = outputTextarea.scrollHeight;
            }

            function clearLastPoint() {
                if (trackPoints.length > 0) {
                    trackPoints.pop();
                    if (trackPoints.length === 0) baseTime = null;
                    drawTrack();
                    updateOutput();
                }
            }

            function exportData() {
                const data = outputTextarea.value;
                if (!data) return;
                const blob = new Blob([data], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${basinInput.value}${systemIdInput.value}_track.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            function roundToSynopticTime(date) {
                const roundedDate = new Date(date.getTime());
                const hours = roundedDate.getUTCHours();
                roundedDate.setUTCHours(Math.floor(hours / 6) * 6, 0, 0, 0);
                return roundedDate;
            }

            function formatToUTCString(date) {
                return date.toISOString().slice(0, 13).replace(/[-T]/g, '');
            }
            
            function formatToDateTimeLocal(date) {
                const year = date.getFullYear();
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const day = date.getDate().toString().padStart(2, '0');
                const hours = date.getHours().toString().padStart(2, '0');
                const minutes = date.getMinutes().toString().padStart(2, '0');
                return `${year}-${month}-${day}T${hours}:${minutes}`;
            }

            // --- START THE APP ---
            initialize();
        });
    </script>

</body>
</html>
